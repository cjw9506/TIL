# [JPA] 영속성 컨텍스트란?

-   EntityManager
    -   엔티티를 관리하는 역할.
    -   엔티티 매니저 내부에는 영속성 컨텍스트가 있으며, 이를 통해 엔티티 관리.
    -   여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유 가능
    -   EntityManager 는 Thread-Safe 를 보장해야 한다. 동일한 EntityManager 를 가지고 멀티 스레드 환경에서 호출한다면 데이터가 어떻게 변경될지 모름.

---

-   영속성 컨텍스트
    -   JPA를 이해하는데 가장 중요하고, "엔티티를 영구 저장하는 환경" 이라는 뜻이다.
    -   영속성 컨텍스트는 관리하고 있는 엔티티의 변화를 추적하고, 한 트랜잭션 내에서 변화가 일어나면 엔티티에 마킹한다.
    -   트랜잭션이 끝나는 시점에 마킹한 것을 DB 에 반영해준다.(더티체킹)

---

-   엔티티의 생명주기
    -   비영속 - 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
    -   영속 - 영속성 컨텍스트에 관리되는 상태
    -   준영속 - 영속성 컨텍스트에 저장되었다가 분리된 상태
    -   삭제 - 삭제된 상태

```java
//객체를 생성한 상태(비영속)
Member member = new Member();
member.setId("memberA");
member.setUsername("user");

EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

//객체를 저장한 상태(영속)
em.persist(member);

//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
em.detach(member);

//객체를 삭제한 상태(삭제)
em.remove(member);
```

---

-   영속성 컨텍스트의 이점
    -   1차 캐시 - 영속성 컨텍스트는 내부의 1차 캐시를 가지고 있다. 쉽게 설명하자면, 간이 저장소 느낌이다. 어떤 데이터를 조회할 때 EntityManager 내부 1차 캐시에 조회 데이터가 없다면 DB 조회 후, 1차 캐시에 저장한다음 반환해주고, 나중에 다시 똑같은 데이터를 조회한다면 DB를 거치지 않고 1차 캐시에서 데이터를 반환하면 된다.(성능 이점에선 딱히 의미 없다고 한다...)
    -   영속 엔티티의 동일성 보장 - JPA를 통해 불러온 데이터는 모두 캐시 데이터에 저장되기 때문에 같은 id를 가진 데이터는 같은 데이터이다.
    -   변경 감지 - 데이터를 변경할 때, em.persist를 다시 해주지 않아도 된다. 트랜잭션이 커밋되는 순간에 1차 캐시안에 스냅샷과 엔티티가 일치하는지 확인하는데, 변경을 감지하면 영속 컨텍스트 내부의 쓰기 지연 SQL 저장소에서 업데이트 쿼리를 DB에 날려준다.
    -   트랜잭션을 지원하는 쓰기 지연

```java
//트랜잭션 시작
transaction.begin();

em.persist(memberA);
em.persist(memberB);
//아직 DB에 INSERT SQL을 보내지 않는다.

//commit하는 순간 INSERT SQL을 보낸다.
trasaction.commit();
```

---

-   플러시
    -   영속성 컨텍스트의 변경내용을 데이터베이스에 반영(동기화)하는 것이다.(트랜잭션이 커밋될 때 일어난다.)
    -   쉽게 말해서, 영속성 컨텍스트에서 변경사항과 데이터베이스를 맞추는 작업이라 생각하면 된다.
    -   **플러시가 발생**하면 무슨일이?
        -   변경 감지
        -   수정된 엔티티 쓰기 지연 SQL 저장소에 등록
        -   쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
    -   영속성 컨텍스트를 플러시하는 방법
        -   em.flush() - 직접호출(잘 사용하진 않으나, 테스트 할 때 사용)
        -   트랜잭션 커밋 - 자동 호출
        -   JPQL 쿼리 실행 - 자동 호출